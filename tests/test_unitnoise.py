"""
test_unitnoise
~~~~~~~~~~~~~~

Unit tests for the rasty.unitnoise module.
"""
import numpy as np

from rasty import unitnoise as un
from tests.common import SourceTestCase


# Base class test cases.
class UnitNoiseTestCase(SourceTestCase):
    cls = un.UnitNoise
    
    def test_fill(self):
        """Given the size of each dimension of the noise,
        UnitNoise.fill should return an array that contains
        the expected noise.
        """
        # Expected values.
        exp = np.array([
            [
                [0x60, 0x5a, 0x54, 0x58, 0x5c, 0x6d, 0x7f, 0x42],
                [0x33, 0x36, 0x3a, 0x6f, 0xa4, 0x8b, 0x73, 0x78],
                [0x06, 0x13, 0x21, 0x87, 0xed, 0xaa, 0x67, 0xae],
                [0x7d, 0x62, 0x46, 0x6a, 0x8f, 0x88, 0x81, 0x9f],
                [0xf5, 0xb0, 0x6c, 0x4e, 0x31, 0x66, 0x9b, 0x91],
                [0xbe, 0x8a, 0x57, 0x72, 0x8e, 0xa9, 0xc5, 0x9d],
                [0x87, 0x64, 0x42, 0x96, 0xeb, 0xed, 0xef, 0xaa],
                [0x76, 0x58, 0x3a, 0x5f, 0x83, 0x82, 0x81, 0x8a],
            ],
            [
                [0x62, 0x53, 0x43, 0x3f, 0x3c, 0x42, 0x49, 0x56],
                [0x63, 0x47, 0x2c, 0x61, 0x96, 0x86, 0x75, 0x80],
                [0x64, 0x3c, 0x15, 0x83, 0xf1, 0xc9, 0xa1, 0xab],
                [0x8c, 0x75, 0x5e, 0x8e, 0xbf, 0xa4, 0x8a, 0x99],
                [0xb4, 0xad, 0xa7, 0x9a, 0x8d, 0x80, 0x72, 0x87],
                [0xa8, 0xa5, 0xa2, 0x97, 0x8c, 0x90, 0x93, 0x99],
                [0x9c, 0x9d, 0x9e, 0x95, 0x8c, 0xa0, 0xb5, 0xaa],
                [0x9e, 0x90, 0x82, 0x67, 0x4d, 0x67, 0x82, 0x98],
            ],
        ], dtype=np.uint8)

        # Set up test data and state.
        kwargs = {
            'unit': (2, 2, 2),
            'min': 0x00,
            'max': 0xff,
            'seed': 'spam',
        }
        cls = self.cls

        # Perform test.
        self.fill_test(exp, cls, kwargs)
    
    def test_seeded_table_creation(self):
        """When initialized with a seed value, UnitNoise should use
        that value to seed the random generation of its table.
        """
        # Expected value.
        exp = [3, 1, 0, 2, 3, 5, 0, 2, 1, 5, 4, 4]
        
        # Test data and state.
        kwargs = {
            'unit': (4, 4, 4),
            'min': 0,
            'max': 6,
            'repeats': 1,
            'seed': 'spam',
        }
        
        # Run test.
        obj = self.cls(**kwargs)
        act = obj._table
        
        # Determine test result.
        self.assertListEqual(exp, act)

    def test_table_too_small_for_fill(self):
        """UnitNoise.fill should raise a ValueError exception if the
        table is too small for the amount of noise being generated.
        """
        # Expected values.
        exp_ex = ValueError
        exp_msg = 'Randomized table too small for requested size.'
        
        # Test data and state.
        kwargs = {
            'unit': (1, 1, 1),
            'min': 0x00,
            'max': 0x04,
            'seed': 'spam',
        }
        noise = self.cls(**kwargs)
        size = (1, 8, 8)
        
        # Run test and determine result.
        with self.assertRaisesRegex(exp_ex, exp_msg):
            _ = noise.fill(size)


# Unit noise subclass test cases.
class CosineCurtainsTestCase(UnitNoiseTestCase):
    cls = un.CosineCurtains
    
    def test_fill(self):
        """When given the size of the image data to fill, 
        CosineCurtains.fill should return an array filled with
        randomized data that looks somewhat like curtains.
        """
        # Expected value.
        exp = np.array([
            [
                [0x60, 0x5e, 0x5a, 0x55, 0x54, 0x55, 0x58, 0x5a],
                [0x60, 0x5e, 0x5a, 0x55, 0x54, 0x55, 0x58, 0x5a],
                [0x60, 0x5e, 0x5a, 0x55, 0x54, 0x55, 0x58, 0x5a],
                [0x60, 0x5e, 0x5a, 0x55, 0x54, 0x55, 0x58, 0x5a],
                [0x60, 0x5e, 0x5a, 0x55, 0x54, 0x55, 0x58, 0x5a],
                [0x60, 0x5e, 0x5a, 0x55, 0x54, 0x55, 0x58, 0x5a],
                [0x60, 0x5e, 0x5a, 0x55, 0x54, 0x55, 0x58, 0x5a],
                [0x60, 0x5e, 0x5a, 0x55, 0x54, 0x55, 0x58, 0x5a],
            ],
            [
                [0x5f, 0x5e, 0x5c, 0x5b, 0x5a, 0x58, 0x54, 0x51],
                [0x5f, 0x5e, 0x5c, 0x5b, 0x5a, 0x58, 0x54, 0x51],
                [0x5f, 0x5e, 0x5c, 0x5b, 0x5a, 0x58, 0x54, 0x51],
                [0x5f, 0x5e, 0x5c, 0x5b, 0x5a, 0x58, 0x54, 0x51],
                [0x5f, 0x5e, 0x5c, 0x5b, 0x5a, 0x58, 0x54, 0x51],
                [0x5f, 0x5e, 0x5c, 0x5b, 0x5a, 0x58, 0x54, 0x51],
                [0x5f, 0x5e, 0x5c, 0x5b, 0x5a, 0x58, 0x54, 0x51],
                [0x5f, 0x5e, 0x5c, 0x5b, 0x5a, 0x58, 0x54, 0x51],
            ],
            [
                [0x5e, 0x5f, 0x63, 0x67, 0x69, 0x61, 0x4d, 0x39],
                [0x5e, 0x5f, 0x63, 0x67, 0x69, 0x61, 0x4d, 0x39],
                [0x5e, 0x5f, 0x63, 0x67, 0x69, 0x61, 0x4d, 0x39],
                [0x5e, 0x5f, 0x63, 0x67, 0x69, 0x61, 0x4d, 0x39],
                [0x5e, 0x5f, 0x63, 0x67, 0x69, 0x61, 0x4d, 0x39],
                [0x5e, 0x5f, 0x63, 0x67, 0x69, 0x61, 0x4d, 0x39],
                [0x5e, 0x5f, 0x63, 0x67, 0x69, 0x61, 0x4d, 0x39],
                [0x5e, 0x5f, 0x63, 0x67, 0x69, 0x61, 0x4d, 0x39],
            ],
        ], dtype=np.uint8)
        
        # Test data and state.
        kwargs = {
            'unit': (4, 4, 4),
            'min': 0x00,
            'max': 0xff,
            'seed': 'spam',
        }
        cls = un.CosineCurtains
        
        # Run test and determine result.
        self.fill_test(exp, cls, kwargs)


class CurtainsTestCase(UnitNoiseTestCase):
    cls = un.Curtains
    
    def test_fill(self):
        """When given the size of the image data to fill, Curtains.fill
        should return an array filled with randomized data that looks
        somewhat like curtains.
        """
        # Expected value.
        exp = np.array([
            [
                [0x60, 0x5a, 0x54, 0x58, 0x5c, 0x6d, 0x7f, 0x42],
                [0x60, 0x5a, 0x54, 0x58, 0x5c, 0x6d, 0x7f, 0x42],
                [0x60, 0x5a, 0x54, 0x58, 0x5c, 0x6d, 0x7f, 0x42],
                [0x60, 0x5a, 0x54, 0x58, 0x5c, 0x6d, 0x7f, 0x42],
                [0x60, 0x5a, 0x54, 0x58, 0x5c, 0x6d, 0x7f, 0x42],
                [0x60, 0x5a, 0x54, 0x58, 0x5c, 0x6d, 0x7f, 0x42],
                [0x60, 0x5a, 0x54, 0x58, 0x5c, 0x6d, 0x7f, 0x42],
                [0x60, 0x5a, 0x54, 0x58, 0x5c, 0x6d, 0x7f, 0x42],
            ],
            [
                [0x33, 0x36, 0x3a, 0x6f, 0xa4, 0x8b, 0x73, 0x78],
                [0x33, 0x36, 0x3a, 0x6f, 0xa4, 0x8b, 0x73, 0x78],
                [0x33, 0x36, 0x3a, 0x6f, 0xa4, 0x8b, 0x73, 0x78],
                [0x33, 0x36, 0x3a, 0x6f, 0xa4, 0x8b, 0x73, 0x78],
                [0x33, 0x36, 0x3a, 0x6f, 0xa4, 0x8b, 0x73, 0x78],
                [0x33, 0x36, 0x3a, 0x6f, 0xa4, 0x8b, 0x73, 0x78],
                [0x33, 0x36, 0x3a, 0x6f, 0xa4, 0x8b, 0x73, 0x78],
                [0x33, 0x36, 0x3a, 0x6f, 0xa4, 0x8b, 0x73, 0x78],
            ],
            [
                [0x06, 0x13, 0x21, 0x87, 0xed, 0xaa, 0x67, 0xae],
                [0x06, 0x13, 0x21, 0x87, 0xed, 0xaa, 0x67, 0xae],
                [0x06, 0x13, 0x21, 0x87, 0xed, 0xaa, 0x67, 0xae],
                [0x06, 0x13, 0x21, 0x87, 0xed, 0xaa, 0x67, 0xae],
                [0x06, 0x13, 0x21, 0x87, 0xed, 0xaa, 0x67, 0xae],
                [0x06, 0x13, 0x21, 0x87, 0xed, 0xaa, 0x67, 0xae],
                [0x06, 0x13, 0x21, 0x87, 0xed, 0xaa, 0x67, 0xae],
                [0x06, 0x13, 0x21, 0x87, 0xed, 0xaa, 0x67, 0xae],
            ],
        ], dtype=np.uint8)
        
        # Test data and state.
        kwargs = {
            'unit': (2, 2, 2),
            'min': 0x00,
            'max': 0xff,
            'seed': 'spam',
        }
        cls = un.Curtains
        
        # Run test and determine result.
        self.fill_test(exp, cls, kwargs)


class OctaveCosineCurtainsTestCase(SourceTestCase):
    def test_fill(self):
        """When given the size of the image data to fill, 
        OctaveCosineCurtain.fill should return an array filled
        with unit noise.
        """
        # Expected value.
        exp = np.array([
            [
                [0x60, 0x5e, 0x59, 0x55, 0x54, 0x55, 0x58, 0x5a],
                [0x60, 0x5e, 0x59, 0x55, 0x54, 0x55, 0x58, 0x5a],
                [0x60, 0x5e, 0x59, 0x55, 0x54, 0x55, 0x58, 0x5a],
                [0x60, 0x5e, 0x59, 0x55, 0x54, 0x55, 0x58, 0x5a],
                [0x60, 0x5e, 0x59, 0x55, 0x54, 0x55, 0x58, 0x5a],
                [0x60, 0x5e, 0x59, 0x55, 0x54, 0x55, 0x58, 0x5a],
                [0x60, 0x5e, 0x59, 0x55, 0x54, 0x55, 0x58, 0x5a],
                [0x60, 0x5e, 0x59, 0x55, 0x54, 0x55, 0x58, 0x5a],
            ],
            [
                [0x5f, 0x5e, 0x5c, 0x5b, 0x5a, 0x58, 0x54, 0x51],
                [0x5f, 0x5e, 0x5c, 0x5b, 0x5a, 0x58, 0x54, 0x51],
                [0x5f, 0x5e, 0x5c, 0x5b, 0x5a, 0x58, 0x54, 0x51],
                [0x5f, 0x5e, 0x5c, 0x5b, 0x5a, 0x58, 0x54, 0x51],
                [0x5f, 0x5e, 0x5c, 0x5b, 0x5a, 0x58, 0x54, 0x51],
                [0x5f, 0x5e, 0x5c, 0x5b, 0x5a, 0x58, 0x54, 0x51],
                [0x5f, 0x5e, 0x5c, 0x5b, 0x5a, 0x58, 0x54, 0x51],
                [0x5f, 0x5e, 0x5c, 0x5b, 0x5a, 0x58, 0x54, 0x51],
            ],
            [
                [0x5e, 0x5f, 0x63, 0x67, 0x69, 0x61, 0x4d, 0x39],
                [0x5e, 0x5f, 0x63, 0x67, 0x69, 0x61, 0x4d, 0x39],
                [0x5e, 0x5f, 0x63, 0x67, 0x69, 0x61, 0x4d, 0x39],
                [0x5e, 0x5f, 0x63, 0x67, 0x69, 0x61, 0x4d, 0x39],
                [0x5e, 0x5f, 0x63, 0x67, 0x69, 0x61, 0x4d, 0x39],
                [0x5e, 0x5f, 0x63, 0x67, 0x69, 0x61, 0x4d, 0x39],
                [0x5e, 0x5f, 0x63, 0x67, 0x69, 0x61, 0x4d, 0x39],
                [0x5e, 0x5f, 0x63, 0x67, 0x69, 0x61, 0x4d, 0x39],
            ],
        ], dtype=np.uint8)
       
        # Tests data and state.
        cls = un.OctaveCosineCurtains
        kwargs = {
            'unit': (4, 4, 4),
            'seed': 'spam',
        }
        
        # Run test and determine result.
        self.fill_test(exp, cls, kwargs)


class OctaveCurtainsTestCase(SourceTestCase):
    def test_fill(self):
        """When given the size of the image data to fill, 
        OctaveCurtain.fill should return an array filled with 
        unit noise.
        """
        # Expected value.
        exp = np.array([
            [
                [0x60, 0x5c, 0x59, 0x57, 0x54, 0x56, 0x58, 0x59],
                [0x60, 0x5c, 0x59, 0x57, 0x54, 0x56, 0x58, 0x59],
                [0x60, 0x5c, 0x59, 0x57, 0x54, 0x56, 0x58, 0x59],
                [0x60, 0x5c, 0x59, 0x57, 0x54, 0x56, 0x58, 0x59],
                [0x60, 0x5c, 0x59, 0x57, 0x54, 0x56, 0x58, 0x59],
                [0x60, 0x5c, 0x59, 0x57, 0x54, 0x56, 0x58, 0x59],
                [0x60, 0x5c, 0x59, 0x57, 0x54, 0x56, 0x58, 0x59],
                [0x60, 0x5c, 0x59, 0x57, 0x54, 0x56, 0x58, 0x59],
            ],
            [
                [0x5f, 0x5e, 0x5e, 0x5e, 0x5e, 0x58, 0x52, 0x4c],
                [0x5f, 0x5e, 0x5e, 0x5e, 0x5e, 0x58, 0x52, 0x4c],
                [0x5f, 0x5e, 0x5e, 0x5e, 0x5e, 0x58, 0x52, 0x4c],
                [0x5f, 0x5e, 0x5e, 0x5e, 0x5e, 0x58, 0x52, 0x4c],
                [0x5f, 0x5e, 0x5e, 0x5e, 0x5e, 0x58, 0x52, 0x4c],
                [0x5f, 0x5e, 0x5e, 0x5e, 0x5e, 0x58, 0x52, 0x4c],
                [0x5f, 0x5e, 0x5e, 0x5e, 0x5e, 0x58, 0x52, 0x4c],
                [0x5f, 0x5e, 0x5e, 0x5e, 0x5e, 0x58, 0x52, 0x4c],
            ],
            [
                [0x5e, 0x60, 0x63, 0x66, 0x69, 0x5b, 0x4d, 0x3f],
                [0x5e, 0x60, 0x63, 0x66, 0x69, 0x5b, 0x4d, 0x3f],
                [0x5e, 0x60, 0x63, 0x66, 0x69, 0x5b, 0x4d, 0x3f],
                [0x5e, 0x60, 0x63, 0x66, 0x69, 0x5b, 0x4d, 0x3f],
                [0x5e, 0x60, 0x63, 0x66, 0x69, 0x5b, 0x4d, 0x3f],
                [0x5e, 0x60, 0x63, 0x66, 0x69, 0x5b, 0x4d, 0x3f],
                [0x5e, 0x60, 0x63, 0x66, 0x69, 0x5b, 0x4d, 0x3f],
                [0x5e, 0x60, 0x63, 0x66, 0x69, 0x5b, 0x4d, 0x3f],
            ],
        ], dtype=np.uint8)
       
        # Tests data and state.
        cls = un.OctaveCurtains
        kwargs = {
            'unit': (4, 4, 4),
            'seed': 'spam',
        }
        
        # Run test and determine result.
        self.fill_test(exp, cls, kwargs)


class OctaveUnitNoise(SourceTestCase):
    def test_fill(self):
        """When given the size of the image data to fill, 
        OctaveUnitNoise.fill should return an array filled with 
        unit noise.
        """
        # Expected value.
        exp = np.array([
            [
                [0x60, 0x5c, 0x59, 0x57, 0x54, 0x56, 0x58, 0x59],
                [0x5f, 0x5e, 0x5e, 0x5e, 0x5e, 0x58, 0x52, 0x4c],
                [0x5e, 0x60, 0x63, 0x66, 0x69, 0x5b, 0x4d, 0x3f],
                [0x5c, 0x62, 0x68, 0x6e, 0x74, 0x5e, 0x47, 0x31],
                [0x5b, 0x64, 0x6d, 0x76, 0x7f, 0x60, 0x42, 0x24],
                [0x46, 0x4e, 0x57, 0x5f, 0x67, 0x5d, 0x53, 0x49],
                [0x31, 0x38, 0x40, 0x48, 0x50, 0x5a, 0x64, 0x6f],
                [0x1b, 0x22, 0x2a, 0x31, 0x38, 0x57, 0x75, 0x94],
            ],
            [
                [0x49, 0x48, 0x48, 0x47, 0x47, 0x55, 0x63, 0x72],
                [0x57, 0x56, 0x55, 0x54, 0x53, 0x5a, 0x62, 0x69],
                [0x64, 0x63, 0x62, 0x61, 0x60, 0x60, 0x60, 0x60],
                [0x72, 0x71, 0x6f, 0x6e, 0x6c, 0x65, 0x5e, 0x58],
                [0x80, 0x7e, 0x7c, 0x7a, 0x78, 0x6b, 0x5d, 0x4f],
                [0x70, 0x6e, 0x6c, 0x69, 0x67, 0x65, 0x64, 0x62],
                [0x61, 0x5e, 0x5b, 0x59, 0x56, 0x60, 0x6b, 0x75],
                [0x51, 0x4e, 0x4b, 0x48, 0x45, 0x5b, 0x72, 0x88],
            ],
            [
                [0x33, 0x34, 0x36, 0x38, 0x3a, 0x55, 0x6f, 0x8a],
                [0x4f, 0x4d, 0x4c, 0x4a, 0x48, 0x5d, 0x71, 0x86],
                [0x6b, 0x66, 0x61, 0x5b, 0x56, 0x65, 0x73, 0x82],
                [0x88, 0x7f, 0x76, 0x6d, 0x64, 0x6d, 0x76, 0x7e],
                [0xa4, 0x98, 0x8b, 0x7f, 0x73, 0x75, 0x78, 0x7a],
                [0x9a, 0x8e, 0x81, 0x74, 0x67, 0x6e, 0x74, 0x7b],
                [0x91, 0x83, 0x76, 0x69, 0x5c, 0x67, 0x71, 0x7b],
                [0x87, 0x79, 0x6c, 0x5f, 0x51, 0x5f, 0x6e, 0x7c],
            ],
        ], dtype=np.uint8)
       
        # Tests data and state.
        cls = un.OctaveUnitNoise
        kwargs = {
            'unit': (4, 4, 4),
            'seed': 'spam',
        }
        
        # Run test and determine result.
        self.fill_test(exp, cls, kwargs)


# Function test cases.
class OctaveNoiseFactory(SourceTestCase):
    def test_has_source(self):
        """Subclasses of OctaveNoise must identify a UnitNoise subclass
        for the creation of octave noise.
        """
        # Expected value.
        exp = un.UnitNoise
        
        # Run test.
        result = un.octave_noise_factory(exp, un.OctaveNoiseDefaults())
        
        # Extract actual value.
        act = result.source
        
        # Determine test result.
        self.assertEqual(exp, act)
    
    def test_set_defaults(self):
        """Created subclasses of OctaveNoise should set the octave
        noise parameter and unit noise parameter defaults.
        """
        # Expected value.
        exp = {
            'octaves': 6,
            'persistence': -4,
            'amplitude': 24,
            'frequency': 4,
            'unit': (1024, 1024, 1024),
            'min': 0x00,
            'max': 0xff,
            'repeats': 1,
            'seed': None,
        }
        
        # Test data and state.
        noise = un.UnitNoise
        defaults = un.OctaveNoiseDefaults(**exp)
        
        # Run test.
        result = un.octave_noise_factory(noise, defaults)
        
        # Extract actual value.
        obj = result()
        act = obj.asdict()
        
        # Determine test result.
        self.assertDictEqual(exp, act)

    def test_set_fill(self):
        """Created subclasses of OctaveNoise should have a fill method
        that generates octave unit noise.
        """
        # Expected value.
        exp = np.array([
            [
                [0x60, 0x5c, 0x59, 0x57, 0x54, 0x56, 0x58, 0x59],
                [0x5f, 0x5e, 0x5e, 0x5e, 0x5e, 0x58, 0x52, 0x4c],
                [0x5e, 0x60, 0x63, 0x66, 0x69, 0x5b, 0x4d, 0x3f],
                [0x5c, 0x62, 0x68, 0x6e, 0x74, 0x5e, 0x47, 0x31],
                [0x5b, 0x64, 0x6d, 0x76, 0x7f, 0x60, 0x42, 0x24],
                [0x46, 0x4e, 0x57, 0x5f, 0x67, 0x5d, 0x53, 0x49],
                [0x31, 0x38, 0x40, 0x48, 0x50, 0x5a, 0x64, 0x6f],
                [0x1b, 0x22, 0x2a, 0x31, 0x38, 0x57, 0x75, 0x94],
            ],
            [
                [0x49, 0x48, 0x48, 0x47, 0x47, 0x55, 0x63, 0x72],
                [0x57, 0x56, 0x55, 0x54, 0x53, 0x5a, 0x62, 0x69],
                [0x64, 0x63, 0x62, 0x61, 0x60, 0x60, 0x60, 0x60],
                [0x72, 0x71, 0x6f, 0x6e, 0x6c, 0x65, 0x5e, 0x58],
                [0x80, 0x7e, 0x7c, 0x7a, 0x78, 0x6b, 0x5d, 0x4f],
                [0x70, 0x6e, 0x6c, 0x69, 0x67, 0x65, 0x64, 0x62],
                [0x61, 0x5e, 0x5b, 0x59, 0x56, 0x60, 0x6b, 0x75],
                [0x51, 0x4e, 0x4b, 0x48, 0x45, 0x5b, 0x72, 0x88],
            ],
            [
                [0x33, 0x34, 0x36, 0x38, 0x3a, 0x55, 0x6f, 0x8a],
                [0x4f, 0x4d, 0x4c, 0x4a, 0x48, 0x5d, 0x71, 0x86],
                [0x6b, 0x66, 0x61, 0x5b, 0x56, 0x65, 0x73, 0x82],
                [0x88, 0x7f, 0x76, 0x6d, 0x64, 0x6d, 0x76, 0x7e],
                [0xa4, 0x98, 0x8b, 0x7f, 0x73, 0x75, 0x78, 0x7a],
                [0x9a, 0x8e, 0x81, 0x74, 0x67, 0x6e, 0x74, 0x7b],
                [0x91, 0x83, 0x76, 0x69, 0x5c, 0x67, 0x71, 0x7b],
                [0x87, 0x79, 0x6c, 0x5f, 0x51, 0x5f, 0x6e, 0x7c],
            ],
        ], dtype=np.uint8)
       
        # Tests data and state.
        noise = un.UnitNoise
        cls = un.octave_noise_factory(noise, un.OctaveNoiseDefaults())
        kwargs = {
            'unit': (4, 4, 4),
            'seed': 'spam',
        }
        
        # Run test and determine result.
        self.fill_test(exp, cls, kwargs)
    
    def test_set_properties(self):
        """Created subclasses of OctaveNoise should set the octave
        noise parameters and unit noise parameters.
        """
        # Expected value.
        exp = {
            'octaves': 4,
            'persistence': 8,
            'amplitude': 8,
            'frequency': 2,
            'unit': (4, 4, 4),
            'min': 0x00,
            'max': 0xff,
            'repeats': 0,
            'seed': 'spam',
        }
        
        # Test data and state.
        noise = un.UnitNoise
        cls = un.octave_noise_factory(noise, un.OctaveNoiseDefaults())
        
        # Run test.
        result = cls(**exp)
        
        # Extract actual value.
        act = result.asdict()
        
        # Determine test result.
        self.assertDictEqual(exp, act)
